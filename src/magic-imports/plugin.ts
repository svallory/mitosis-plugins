import { MitosisComponent, MitosisPlugin, Targets } from '@builder.io/mitosis';
import * as fs from 'fs';
import * as path from 'path';
import {
  MagicImportsPluginOptions,
  ModuleConfig,
  TargetConfig,
  ShimConfig,
  ShimPackageConfig
} from './types';
import {
  findImportsForModule,
  transformImport,
  generateImportStatements
} from './import-parser';

export type {
  MagicImportsPluginOptions,
  ModuleConfig,
  TargetConfig,
  ShimConfig,
  ShimPackageConfig
} from './types';

const DEBUG = !!process.env['DEBUG_MITOSIS'];

// Track if types have been generated this build
let typesGenerated = false;

/**
 * Generate ambient TypeScript definitions for virtual imports.
 */
function generateShimFile(
  modules: Record<string, ModuleConfig>,
  outputPath: string
): void {
  try {
    const definitions: string[] = [
      '/**',
      ' * This file is auto-generated by the magic-imports Mitosis plugin.',
      ' * Do not edit this file directly - any changes will be overwritten.',
      ' * See mitosis.config.cjs for configuration.',
      ' */',
      ''
    ];

    for (const [identifier, config] of Object.entries(modules)) {
      if (!config.shim) continue;

      definitions.push(`declare module "${identifier}" {`);

      const shimValue = config.shim;

      if (typeof shimValue === 'string') {
        // Simple string: export * from this package
        definitions.push(`    export * from "${shimValue}";`);
      } else {
        // Object: per-package configuration
        for (const [pkg, pkgConfig] of Object.entries(shimValue)) {
          if (pkgConfig === '*') {
            // Shorthand for reexportAll
            definitions.push(`    export * from "${pkg}";`);
          } else {
            const config = pkgConfig as ShimPackageConfig;

            // Generate alias exports first
            if (config.aliases) {
              for (const [localName, exportedName] of Object.entries(config.aliases)) {
                definitions.push(`    export { ${exportedName} as ${localName} } from "${pkg}";`);
              }
            }

            // Generate export * if requested
            if (config.reexportAll) {
              definitions.push(`    export * from "${pkg}";`);
            }
          }
        }
      }

      definitions.push(`}`);
      definitions.push('');
    }

    if (definitions.length === 6) return; // Only header, no definitions

    const content = definitions.join('\n');
    const dtsPath = path.resolve(process.cwd(), outputPath);

    // Ensure directory exists
    fs.mkdirSync(path.dirname(dtsPath), { recursive: true });

    // Only write if content changed
    if (fs.existsSync(dtsPath)) {
      const existing = fs.readFileSync(dtsPath, 'utf8');
      if (existing === content) return;
    }

    fs.writeFileSync(dtsPath, content);
    console.log(`[MagicImports] Generated shim at ${dtsPath}`);
  } catch (err) {
    console.error('[MagicImports] Failed to generate shim:', err);
  }
}

/**
 * Extract leading indentation from a string.
 */
function extractIndent(str: string): string {
  const match = str.match(/^([ \t]*)/);
  return match ? match[1] : '';
}

/**
 * Process imports in code: parse, transform, and regenerate.
 * Preserves original indentation for frameworks like Svelte.
 */
function processImports(
  code: string,
  identifier: string,
  targetConfig: TargetConfig
): string {
  const imports = findImportsForModule(code, identifier);

  if (imports.length === 0) return code;

  let newCode = code;

  for (const parsed of imports) {
    const transformed = transformImport(parsed, targetConfig);
    const newImports = generateImportStatements(transformed);

    // Extract indentation from original import
    const indent = extractIndent(parsed.original);

    // Apply indentation to each generated import line
    const indentedImports = newImports.map(stmt => indent + stmt);

    // Replace original import with new imports
    newCode = newCode.replace(parsed.original, indentedImports.join('\n'));
  }

  return newCode;
}

/**
 * Magic Imports Plugin - Enables virtual imports with framework-specific mappings.
 *
 * @example
 * ```js
 * magicImportsPlugin({
 *   shimOutputFile: 'src/typings/magic-imports.d.ts',
 *   modules: {
 *     'lucide': {
 *       shim: 'lucide-react',
 *       targets: {
 *         react: 'lucide-react',
 *         vue: 'lucide-vue-next'
 *       }
 *     }
 *   }
 * })
 * ```
 */
const magicImportsPlugin = (
  options: MagicImportsPluginOptions
): MitosisPlugin => {
  const {
    modules,
    shimOutputFile = 'src/typings/magic-imports.d.ts'
  } = options;

  // Normalize config: prepend 'virtual:' to keys if missing
  const normalizedModules: Record<string, ModuleConfig> = {};

  for (const [key, config] of Object.entries(modules)) {
    const moduleName = key.startsWith('virtual:') ? key : `virtual:${key}`;
    normalizedModules[moduleName] = config;
  }

  // Generate shim file once per build (if enabled)
  if (!typesGenerated && shimOutputFile !== false) {
    generateShimFile(normalizedModules, shimOutputFile);
    typesGenerated = true;
  }

  return () => ({
    name: 'magic-imports',

    code: {
      post: (code: string, json: MitosisComponent) => {
        const target = json.pluginData?.target as Targets | undefined;

        if (!target) {
          if (DEBUG) {
            console.warn('[MagicImports] No target found for replacement.');
          }
          return code;
        }

        let newCode = code;

        for (const [identifier, config] of Object.entries(normalizedModules)) {
          const targetConfig = config.targets[target];

          if (!targetConfig) {
            if (DEBUG) {
              console.log(`[MagicImports] No config for target '${target}' in module '${identifier}'`);
            }
            continue;
          }

          newCode = processImports(newCode, identifier, targetConfig);
        }

        return newCode;
      }
    }
  });
};

export default magicImportsPlugin;
